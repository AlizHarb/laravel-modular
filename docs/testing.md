# Testing Modules

Laravel Modular seamlessly integrates with **Pest** (recommended) and PHPUnit.

## Test Structure

Every module has its own `tests/` folder.

```text
modules/Shop/
└── tests/
    ├── Feature/
    ├── Unit/
    ├── Pest.php      <-- Module-specific test configuration
    └── TestCase.php  <-- Base test case
```

## Running Tests

### 1. Running All Tests (Global)
When you run `pest` or `phpunit` from your project root, it naturally discovers tests in `modules/*/tests` because the `phpunit.xml` generated by `make:module` is merged or configured to look there.

### 2. Running Specific Module Tests
Use the Artisan command to isolate tests for one module.

```bash
# Run tests ONLY for Shop
php artisan modular:test Shop
```

This command:
1.  Points PHPUnit to `modules/Shop/phpunit.xml`.
2.  Ensures strictly that only this module's tests run.

---

## Writing Tests

Your module's `TestCase.php` usually extends `Tests\TestCase` (the application's base test case).

**Example Application Test:**
```php
// packages/modular/Shop/tests/Feature/CartTest.php

use Modules\Shop\Models\Product;

it('can add items to cart', function () {
    $product = Product::factory()->create();
    
    $response = this->post('/cart', [
        'product_id' => $product->id
    ]);
    
    $response->assertRedirect('/cart');
});
```

### Mocking Other Modules
Since modules are isolated, how do you test interactions?

**Scenario:** Shop module needs to notify the User module.
**Approach:** The Shop module should depend on an Interface, not the User class. You can then mock that interface.

```php
// In ShopServiceProvider
$this->app->bind(UserRepositoryInterface::class, RealUserRepository::class);

// In Tests
$this->mock(UserRepositoryInterface::class, function ($mock) {
    $mock->shouldReceive('find')->andReturn(...);
});
```
